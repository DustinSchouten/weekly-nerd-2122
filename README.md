# Weekly Nerd

## Vooraf
Tijdens de minor Web Design and Development zijn er een aantal gastcolleges (weekly nerds) gehouden Voor het schrijven van een reflectie bij iedere weekly nerd heb ik eerst een korte introductie gegeven over de gastspreker en hetgeen er in de weekly nerd verteld is. Dit geeft voor mij de basis om er een goed onderbouwde reflectie over te schrijven. Ditzelfde principe heb ik bij de weekly mingles toegepast. Achteraan dit document staan de drie geschreven artikelen.

### Weekly Nerd

#### Cyd Stumpel (10 februari 2022)
Cyd vertelde in haar presentatie welke werkzaamheden ze bij haar bedrijf verricht. Als frontender web development bouwt ze websites en andere producten voor bedrijven. Hierbij liet zij deze websites en stukken code zien. Ook vertelde ze dat ze veel overlegt met designers omdat ze niet de websites zelf ontwerpt. Deze werkzaamheden spreken mij erg aan, omdat ik zelf ook erg houd van web development en de logica die bij het coderen komt kijken. Alleen het designaspect spreekt mij iets minder aan doordat ik geen ervaring heb met photoshopprogramma’s en het liefst niet aan een bepaald design gebonden zit. Wat mij dan wel weer aansprak was het feit dat je grotendeels zelf mocht bepalen hoe de websites eruit komen te zien en welke interacties er komen na gebruikersonderzoek. Ik vind het namelijk erg leuk om erachter te komen waar de eindgebruikers tevreden van worden en om deze bepaalde functionaliteiten vervolgens te kunnen uitprogrammeren.

Verder heeft zij in haar presentatie verteld dat ze bij Awwards als jury websites van designers en developers beoordeelt die de makers kunnen insturen en dat ze ook nieuwe werknemers mag begeleiden. Ook van deze functies, die veel met communicatie te maken hebben, ben ik niet zo’n fan. Al met al ben ik wel erg geïnspireerd geraakt door de mooie websites die Sid heeft laten zien.

#### Alvaro Montoro (16 februari 2022)
Alvaro is extreem goed in het maken van CSS kunstwerken, zonder ook maar één regel JavaScript of andere programmeertalen, frameworks en librarieste gebruiken. Hij gebruikt hier enkel HTML en CSS voor. Hij gebruikt ook geen SVG images omdat deze meer opslag kosten. Zijn pakkende quote hiervoor is dan ook: ‘In a world of JS and over-engineered websites, enhace the simplicity and freshness of using plain HTML and CSS.’ Hierbij wil hij andere designers en developers laten zien dat CSS inmiddels een zeer krachtige taal is.

Hij heeft ons een flink aantal codepens met CSS kunstwerken laten zien waarvan ik denk dat de meeste front-end developers dit zelfs met JavaScript of andere hulpmiddelen niet eens kunnen namaken. Dit vond ik ontzettend knap en ik was met name erg verbaasd over het feit dat je met enkel HTML en CSS ook zoveel interacties kon maken. Een voorbeeld was een werkende boter-kaas-en-eieren codepen.

Dit heeft mij dan ook zeker geïnspireerd om nog meer over de taal CSS te leren. Zelf vind ik het namelijk erg leuk om in mijn vrije tijd met HTML, CSS en JavaScript (ervaring met andere technische hulpmiddelen en designprogramma’s heb ik helaas niet) web apps en games te maken (zoals 4 op een rij, pacman of een quiz app). Vaak besteedde ik hierbij de meeste aandacht aan de functionaliteiten die ik dan met JavaScript maakte en minder aandacht aan de styling. Na deze presentatie heb ik gezien dat het eigenlijk minstens zo leuk is om met jouw project ook gewoon wat meer indruk bij anderen te maken. Alleen zal ik na deze demonstratie niet proberen om alles met CSS op te lossen, omdat ik het uiteindelijk toch leuker vind om gewoon lekker te kunnen programmeren.

#### Fenna de Wilde (2 maart 2022)
Fenna is een frontend developer met een passie voor design. Voor verschillende klanten maakt ze websites. In de presentatie heeft zij een scroll-based website aan ons laten zien die enkele zeer mooie en uitgebreide animaties bevatte. In deze website waren o.a. ook posters aanwezig die geen images waren, maar die ze zelf met HTML heeft gemaakt. 

Wat ik erg interessant vond was dat er op die posters teksten waren die op basis van de brightness van de pixels een zwarte of witte kleur toegekend kregen. Een relatief donkere poster krijgt bijvoorbeeld een witte tekst. Dit heeft ze naar eigen zeggen met scripts gemaakt waarbij ze ook wat wiskunde heeft toegepast. Zelf ben ik ook goed in wiskundige vakken en houd ik er erg van om mooie projecten (zoals websites en games, zie vorige weekly nerd) te maken waarbij er vooral veel logica bij komt kijken. 

Later in de presentatie liet Fenna ook een aantal animaties zien waarbij ze vertelde dat dit viel onder ‘generated art’. Dat houdt in dat de ‘kunst’ (in dit geval de CSS-animaties) door computers d.m.v. wiskunde en algoritmes wordt gegenereerd waarbij de inbreng van mensen beperkt is. Ook dit vond ik interessant om te zien en ik zou ook graag te weten willen komen hoe deze algoritmes in zijn werk gaan.

Een ander onderwerp waar haar presentatie over ging was toegankelijkheid bij websites. Ze vertelde dat ze op school veel leerde over het belang van toegankelijkheid, maar dat ze tijdens stages en op het werkveld merkte dat daar helemaal niet zoveel aandacht aan werd besteed. Dit vond ik erg vreemd omdat je zou verwachten dat een bedrijf er alles aan zou doen om hun website voor zoveel mogelijk (potentiële) klanten toegankelijk te maken. Maar dit blijkt in de praktijk dus vaak niet het geval. Hierna kwam ze met wat tips over toegankelijkheid zoals reduce-motion, een aria-label voor screenreaders en focus state bij tabs. Ook kwam ze met een quote waar ik het 100% mee eens was: “Wat is de waarde van een website die alleen maar mooi is?”.

Eerlijk gezegd vind ik dit niet een van mijn favoriete bezigheden, maar ik vind dit wel belangrijk en was ook erg blij met de tips die ze ons meegaf. Dit draagt uiteindelijk toch bij aan het realiseren van een mooi product en ik ben wel iemand die houd van het totaalplaatje: een website (of een ander product) moet vooral goed functioneren maar moet ook door iedereen te gebruiken zijn en er goed uitzien.

#### Krijn Hoetmer (23 maart 2022)
Krijn is een freelance web developer die al ruim 20 jaar lang robuuste websites bouwt. Hij gebruikt hiervoor HTML, CSS, JavaScript en naar eigen zeggen ‘een beetje backend’.

Krijn heeft in zijn presentatie een demo gegeven van zijn zelf ontwikkelde scoresysteem die hij voor zijn badmintonvereniging heeft gebouwd. Ook heeft hij d.m.v. foto’s laten zien dat zijn systeem door iedereen op de vereniging gebruikt wordt. In de badmintonzaal hangen allemaal schermen waarbij je d.m.v. het scannen van een QR-code een scorebord op je telefoon kunt bedienen. Verder heeft het systeem de mogelijkheid om d.m.v. Youtube live te gaan. Link naar zijn applicatie: https://scorenu.app.

Krijn heeft verder in zijn verhaal ook verteld dat hij zijn applicatie heeft laten testen bij verschillende gebruikers. Hierbij wilde hij achterhalen hoe de applicatie gebruikt wordt door anderen en heeft hij een hoop feedback gekregen.

Uiteindelijk heeft hij ook een aantal lessen geleerd tijdens het ontwikkelen van websites in het algemeen, zoals het instant laden van HTML (progressive enhancement) en het feit dat alles wat je als developer maakt misbruikt kan wordt door gebruikers. Zijn conclusie is dan ook: ‘een web app is nooit echt af want er worden altijd weer aanpassingen gedaan’.

Tot nu toe vind ik dit één van de leukste en meest interessante weekly-nerd projecten die we hebben gehad. Hier heb ik een paar redenen voor:
- De app is erg minimalistisch: Op het scherm worden enkel de namen van de spelers en bijbehorende scores getoond en op het bedieningspaneel kun je de scores updaten, kleuren van de namen aanpassen en de volgorde van de banen wisselen. Zelf houd ik erg van minimalisme bij websites en niet van websites en apps waarbij er veel extra overbodige functionaliteiten zijn.
- De gebruiksvriendelijkheid: Als gebruiker hoef je op je telefoon niet in te loggen, hoef je geen apps te downloaden en hoef je ook geen ingewikkelde verbindingen op te zetten. Je hoeft enkel de QR-code te scannen. Ik vind het erg knap dat je een dusdanig ingewikkeld systeem zo simpel door een gebruiker kunt laten bedienen.
- De technische implementatie: Krijn heeft in zijn presentatie verteld hoe je met je telefoon verbinding kunt maken met een scorescherm en een server die alle scores bijhoudt en alle informatie teruggeeft. Die server behoudt geen constante verbinding met een telefoon, maar vraagt om de zoveel tijd of er scores geüpdatet zijn en zo ja, dan geeft die server de nieuwe scores op het scherm weer. Op die manier hoef je als gebruiker niet op je telefoon nog op een soort ‘submit-button’ te geven. Naast dat dit wederom de gebruiksvriendelijkheid vergroot, heb ik er altijd al van gehouden om dit soort nieuwe (web-)technieken te leren. Uiteindelijk vind ik dit ook interessanter dan het design-aspect van webontwikkeling. Het gaat namelijk echt om de logica achter een systeem.
- Verder vind ik het gewoon erg leuk dat het dus mogelijk is om een systeem te maken dat door een hele vereniging wordt gebruikt. En dat je hierbij gewoon live kan zien dat anderen jouw systeem gebruiken wanneer je even bij je vereniging langskomt.

#### Vitaly Friedman (30 maart 2022)
<em>De presentatie van Vitaly Friedman heb ik helaas niet kunnen bijwonen vanwege aanhoudende hoofdpijn.</em>

#### Chanel Mepchen (13 april 2022)
Chanel heeft ons in haar presentatie verteld hoe de setup van een project (zoals een app of een website) bij Triple op het werkveld eruitziet. Hieruit bleek dat zo’n setup bij Triple (en setups bij projecten op het werkveld in het algemeen) in werkelijkheid veel geavanceerder is dan hoe hobby- of schoolprojecten zijn. Bij het ontwikkelen van een product worden bij Triple volgens Chanel een grote hoeveelheid aan tools gebruikt. Hieronder beschrijf ik ze in het kort:
- Git voor debuggen en terugzetten naar eerdere versies en om te kunnen achterhalen wie welke code geschreven heeft.
- NPM voor het installeren van packages (kunnen echter wel security issues veroorzaken).
- De frameworks React en Next.js bij grote projecten.
- TypeScript voor typechecking bij JavaScript.
- Eslint en Prettier om code, geschreven door meerdere developers, consistent te houden.
- SASS om redundantie van CSS te verhelpen.
- Webpack en Vite.js als buildtools
- BABEL om JavaScript te converteren zodat ook oudere browsers het kunnen interpreteren.
- Azure en Azure Devops om de projecten live te zetten.
- Dev/acc/prod zodat klanten eerst de website kunnen testen en accepteren, voordat deze live gaat.

Chanel was in haar presentatie, in tegenstelling tot de eerdere weekly nerds waarin de gasten vaak trots hun zelfgemaakte websites/projecten presenteerden, vooral erg informatief. Hierdoor vind ik het was lastig om er een eigen mening over te kunnen vormen.

Ik vind het vooral ontzettend knap dat je in een project, waarin je samenwerkt met meerdere developers, met zo’n verscheidenheid aan tools alsnog zo goed zulke projecten kan opzetten. Dit klinkt misschien raar omdat hulpmiddelen als React, TypeScript en SASS juist ervoor bedoeld zijn om tijd te besparen en om het leven als ontwikkelaar makkelijker te maken.

De reden waarom het mij erg moeilijk lijkt om met deze voor mij veelal onbekende tools om te gaan is dat ik vaak merk dat mijn ‘programmeervrijheid’ een beetje wordt ontnomen als ik geforceerd allerlei frameworks en buildtools moet gebruiken om in te programmeren. Ook lijkt het me niet echt prettig dat mijn geschreven code door allerlei converters wordt gehaald. Ondanks deze aversie tegen het overmatig gebruik van al deze tools, heb ik er wel altijd van gehouden om dit soort nieuwe (web-)technieken te leren. Uiteindelijk vind ik het namelijk het allerleukste om stuk voor stuk nieuwe technieken bij hobbyprojecten in te zetten.

#### Léonie Watson (20 april 2022)
Léonie, die als accessibility engineer bij het W3C werkt, is blind en in haar presentatie leerde zij ons hoe wij als webdevelopers rekening konden houden met mensen die niet kunnen zien. De vraag waar zij in haar presentatie zo uitgebreid mogelijk antwoord op gaf is: “What is a pleasurable user experience for people who cannot see?”.

Léonie maakt, net zoals andere blinde en slechtziende mensen, bij websites gebruik van een screen reader. In haar presentatie liet ze ons een aantal geluidsfragmenten horen. Op die manier demonstreerde ze hoe het gebruik van bepaalde webtechnieken invloed heeft op de manier waarop een screenreader de content op een website voorleest. Denk hierbij o.a. aan:
- het gebruik van het <html lang="en"> attribuut zodat de screenreader de content met het juiste accent voorleest.
- het gebruik van de juiste interpunctie voor de content.
- het correct toepassen van ‘emphasis’ (klemtonen/nadruk) en ‘prosody’ (is de spreker serieus of bv. ironisch)
- het goed beschrijven van afbeeldingen.

Na haar presentatie was ik eigenlijk vooral nog meer overtuigd geraakt van het belang van toegankelijkheid. Toen zij een aantal vooroordelen over blinde en slechtziende mensen naar voren haalde, betrapte ik me erop dat ik tijdens het maken van webpagina’s soms ook te makkelijk omging met mensen met een dergelijke beperking. Mensen met een visuele beperking zijn namelijk ook erg nieuwsgierig naar afbeeldingen op een website die als niet belangrijk genoeg worden gezien met een alt-tag te beschrijven. Een quote van haar is: “Images are always there for a reason, also blind people want to ‘see’ them, also if they look not important. We have to involve these people”. Denk bijvoorbeeld aan achtergrondafbeeldingen die er bijvoorbeeld zijn om de website mooi aan te kleden en een bepaald gevoel bij de gebruiker op te wekken.

Ook andere dingen, zoals het ‘lang’ attribuut en het incorrect spellen van woorden en onjuist gebruik van interpunctie, zijn details die ik soms nog weleens vergeet bij het maken van webpagina’s. Nu ik ervaren heb hoe visueel beperkten met een website omgaan, zal ik in de toekomst nog meer proberen om op dit soort details te letten.

Voor de rest blijf ik het noemenswaardig vinden dat Léonie, net als andere mensen met een beperking, zo goed met hun beperking om kunnen gaan. En ik vind het knap dat zij op een dusdanig vermakelijke manier ons als webdevelopers heeft bijgebracht op welke manieren wij rekening kunnen houden met deze mensen.

#### Rian Rietveld (28 april 2022)
Rian Rietveld hield een gastcollege over ontwerpen voor een cognitieve stoornis (afwijking in de hersenen). In haar presentatie vertelde Rian welke soorten permanente cognitieve beperkingen (zoals ADHD of autisme) en tijdelijk cognitieve beperkingen (zoals een bepaalde gemoedstoestand of een taalbarriëre) er zijn. Hierbij vertelde ze welke invloeden deze beperkingen kunnen hebben op het gebruik van een website. Ook gaf ze hierbij een aantal tips over hoe je als ontwerper zo goed mogelijk rekening kunt houden met deze beperkingen. Een paar tips die ze hierbij gaf waren:
- Maak teksten zo leesbaar mogelijk d.m.v. gebruik van kopjes en niet te lange teksten.
- Zorg dat mensen op een andere manier dan opbellen contact op kunnen nemen (opbellen kan eng zijn)
- Geef de gebruikers de mogelijkheid om automatisch afspelende video’s of animaties stop te zetten.

Met zoals bij eerdere weekly nerds, vond ik het ook hierbij lastig om er mijn mening over te vormen. Ik kan hierbij eigenlijk niks anders zeggen dan dat ik het erg belangrijk vind dat je als webdeveloper ook met deze zaken rekening houdt. Zelf heb ik een lichte vorm van autisme en heb ik ook zo mijn eigen behoeftes bij alledaagse bezigheden en in dit geval bij een website:
- Ik houd van een duidelijke structuur en van voorspelbaarheid. Rian gaf aan dat bijvoorbeeld het gebruik van een stappenplan bij invulformulieren erg kon helpen. Bij het zien van zo’n stappenplan weet ik namelijk precies waar ik aan toe ben en dat geeft mij dan ook rust.
- Ik heb soms moeite met (directe) sociale contacten met minder bekende mensen. Ik vond het daarom ook erg fijn dat Rian in haar presentatie aandacht besteedde aan het geven van alternatieve manieren van contact opnemen. Als ik met iemand contact moet opnemen, dan bel ik die persoon alleen op als er haast geboden is of als er geen andere optie voorhanden is.

### Weekly Mingle

#### Folkert-Jan, Built In Amsterdam (25 mei 2022)
Built In Amsterdam is een bedrijf dat is gericht op e-commerce. Het bedrijf maakt moderne webshops voor hun (veelal internationale) klanten. Volgens Folkert-Jan is het de bedoeling dat mensen, op basis van het gevoel en het merk (branding) dat hun gemaakte websites overdragen, overgaan op het doen van aankopen. De websites worden dus helemaal op maat gemaakt voor de betreffende klant. Dit is bijvoorbeeld precies het tegenovergestelde van een website als Airbnb of Bol.com doordat deze webshops helemaal gestandaardiseerd zijn.

Bij Built In Amsterdam zijn hun webshops zijn erg gericht op het visuele aspect. De getoonde websites zien er modern uit en ze maken vooral veel gebruik van (side) scrolling animations. Soms laten ze zelfs op scroll gebaseerde ‘video’s’ zien. Dit zijn dan bijvoorbeeld foto’s die snel achter elkaar getoond en weggehaald worden, of dit zijn gifjes die on scroll worden afgespeeld of stopgezet worden. De websites worden gemaakt met HTML, CSS, JavaScript en soms met een framework zoals React. Voor het betalingssysteem wordt Shopify in combinaties met een paar andere diensten gebruikt.

Wat ik hiervan kan zeggen is dat ik vooral het idee (dat klanten kopen op basis van gevoel en branding) achter de websites erg leuk bedacht vind, hoewel ik me afvraag of het een erg vernieuwend concept is. De getoonde websites/webshops vond ik ook erg gaaf om te zien, doordat je echt kon zien dat er veel werk achter zit. Ze zien er erg compleet uit en over elk detail is nagedacht. Als voorbeeld liet hij een animatie zien waarbij het leek alsof je langs een muur met schilderijen langsliep. De animatie verliep van links naar rechts en er zat ook een soort 3D effect in die lastiger is om na te maken dan het op voorhand leek. Ook vond ik het leuk om te zien hoe Folkert-Jan trots was om al hun werk met ons te kunnen delen.

Doordat er in de presentatie vooral veel nadruk gelegd werd op de scrolling animations en doordat ik het toch erg gaaf vind hoe je ze kan gebruiken, heb ik er ook één van mijn artikelen over geschreven.

#### Gavin Ligtharn, LabelA (1 juni 2022)
Bij LabelA gaven Gavin Ligtharn en Emils (Engelstalig) een korte presentatie over het bedrijf en over hun werkzaamheden. Zij ontwikkelen zowel Native als React Native applicaties. Ook maken zij Progressive Web applicaties. Ook hebben zij bij hun bedrijf een focus voor UI en UX design. De library Next.js gebruiken zij voor server-side rendering.

Na de presentatie gaf hij met zijn Engels sprekende collega Emils een workshop over TypeScript. Hierin leerde hij ons hoe je datatypes vooraf kunt definiëren. Wanneer je vervolgens over een variabele in de code hovert, laat TypeScript zien welk datatype deze variabele heeft. En wanneer je je afvraagt welke functieparameters je mee moet geven, kun je over de functie heen hoveren waardoor deze alle parameternamen en datatypes in de juiste volgorde laat zien. Hierdoor ‘beschrijft’ de code als het ware zichzelf. Het veroorzaakt minder bugs en daardoor codeer je sneller. Verder vertelde Gavin uit dat bij vrijwel elk bedrijf TypeScript als standaard gebruikt wordt.

Allereerst kon ik het erg waarderen dat zij de moeite namen om voor ons een workshop te organiseren. Ook het onderwerp vind ik goed gekozen omdat ik er op school tot nu toe weinig over heb gehoord terwijl het toch bijna overal in de front-end industrie als standaard gebruikt wordt. De workshop ging over hoe je datatypes bij variabelen, objecten en bij functieparameters definieert. De opdrachten vond ik leuk om te doen, maar ik denk zelf niet dat ik in mijn eigen tijd bij hobbyprojecten met TypeScript aan de slag zal gaan, omdat het voor mij niet voelt alsof het veel meerwaarde heeft.

#### Menno de Vries en Gijs Laarman, DEPT (8 juni 2022)
In de derde weekly mingle kregen wij een presentatie van Menno en Gijs bij het bedrijf DEPT (digital agency). Zij zijn beide frontend developers en het bedrijf richt zich op alles wat te maken heeft met websites, apps, commercials en films. Het bedrijf DEPT heeft ook al eens een Webby award gewonnen.

Menno en Gijs hebben, naast een introductie die eigenlijk iets meer leek op een lange commercial 😉, het grootste deel van de tijd verteld over de manier van werken die ze uitvoeren als ze een nieuwe klantopdracht krijgen. Die ging als volgt: 
- Een nieuwe opdracht wordt door een strategieteam onderzocht op haalbaarheid en precieze eisen en wensen worden verkregen.
- Bij een goedkeuring wordt het designteam (visual design en UX) ingeschakeld dat alvast een ontwerp in Figma maakt om doormiddel van een review te checken of dat echt is wat de klant wil.
- Als de klant akkoord gaat, wordt er een ureninschatting gemaakt en worden de taken verdeeld.
- Dan begint het daadwerkelijke bouwen van de frontend. Tijdens het bouwen houdt iedereen zich aan bepaalde codestandaarden.
- Na de frontend begint het backend team om de website functioneel te maken. Vaak willen klanten hun eigen content op de website kunnen beheren doormiddel van een CMS. Tussentijds wordt er ook getest en gereviewd met de klant.
- Als laatste volgt de oplevering.

Tussendoor lieten Menno en Gijs ons ook wat codevoorbeelden van klanten zien om ons te laten zien hoe zij op microniveau te werk gaan. Een van hun voorbeelden ging over de website van de Haagse Hogeschool. Achteraf wilden zij ons nog wat tips meegeven wat ik heel erg kon waarderen. De beste vond ik: “Laat bij stages alleen projecten zien waar je echt met trots over kan vertellen en laat niet teveel oude schoolprojecten zien.”.

Zelf vond ik dit een hele leuke bijeenkomst en van de drie bezochte bedrijven de beste tot nu toe. Dat lag aan het ontvangst, de professionele maar toch gemoedelijke indruk die het bedrijf en de mensen achterlieten, de presentatie waarbij ik echt de indruk kreeg dat zij ons graag wilde hebben als potentiële collega’s en ook de gestructureerde werkwijze die ze uitvoeren. En ook de websites en commercials die zij als voorbeelden aan ons lieten zien zagen er gewoon prima uit. Dit is eigenlijk hetgeen wat ik erover kan vertellen, want in principe zijn de opzet van de weekly mingles allemaal wel een beetje hetzelfde: bedrijven die ons uitnodigen, een rondleiding geven en iets vertellen over de sfeer en de werkwijze van het bedrijf. Deze vond ik bij dit bedrijf zoals gezegd tot nu toe het beste.

#### De Voorhoede (15 juni 2022)
<em>De presentatie van De Voorhoede heb ik helaas niet kunnen bijwonen vanwege aanhoudende hoofdpijn.</em>

### Wetenschappelijke artikelen

#### Artikel 1: CSS scrolling animations
Tijdens het bouwen van websites kunnen CSS animations worden gebruikt om jouw websites voor bezoekers wat levendiger te maken. Naast dat het er mooier uitziet, houdt het ook meer potentiële klanten langer op jouw website, waardoor de kans groter is dat ze over zullen gaan tot aankopen. Een populair fenomeen bij webdesigners zijn scrolling animations. Dat zijn animaties die getriggerd worden op het moment dat de gebruiker door de website scrolt en het te animeren element zichtbaar (in de viewport) is. Om te laten zien hoe je CSS scrolling animations kunt toepassen, heb ik hieronder een eenvoudig voorbeeld gemaakt. Ik heb een stukje HTML, CSS en JavaScript gemaakt en ik zal per onderdeel uitleggen hoe de code werkt.
Allereerst de HTML. Ik heb een h1 voor de titel en daarbinnen twee sections met per section drie divs gemaakt. Elke div staat voor een vierkantje dat geanimeerd kan worden. De classes shape1 t/m 6 zijn ervoor om ieder element een eigen stijl mee te geven. In dit geval geef ik ze allemaal een andere background-color en rotation mee. Met de class animate_on_scroll geef ik in de HTML aan dat ik wil dat dit element geanimeerd wordt. Zie de HTML hieronder:
```
<html>
    <head>
        <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
        <link rel="stylesheet" href="style.css">    
    </head>
    <body>
        <h1>Scroll voor animaties</h1>
        <section>
            <div class="shape1 animate_on_scroll"></div>
            <div class="shape2 animate_on_scroll"></div>
            <div class="shape3 animate_on_scroll"></div>
        </section>
        <section>
            <div class="shape4 animate_on_scroll"></div>
            <div class="shape5 animate_on_scroll"></div>
            <div class="shape6 animate_on_scroll"></div>
        </section>
        <script src="javascript.js"></script>
    </body>
</html>
```
Dan de CSS. De meeste stukken code zijn niet zo interessant. Het enige noemenswaardige in dit stuk is dat ik de class animate_on_scroll een transition heb meegegeven. Voor de rest heb ik alle shapes eigen waardes meegegeven die ‘on scroll’ worden getoond. Zie de CSS hieronder:
```
* {
    padding: 0;
    margin: 0;
    font-family: 'system-ui';
    box-sizing: border-box;
}

h1 {
    font-size: 10em;
    height: 100vh;
    background-color: blue;
    padding: 50px;
}

section {
    height: 100vh;
    padding: 50px;
    display: flex;
}

.animate_on_scroll {
    transition: 2s all ease;
}

div {
    margin-right: 30px;
    width: 300px;
    height: 300px;
    background-color: black;
}

.shape1.animated {
    transform: rotate(90deg);
    background-color: red;
}

.shape2.animated {
    transform: rotate(-90deg);
    background-color: orange;
}

.shape3.animated {
    transform: rotate(180deg);
    background-color: yellow;
}

.shape4.animated {
    transform: rotate(90deg);
    background-color: green;
}

.shape5.animated {
    transform: rotate(-90deg);
    background-color: blue;
}

.shape6.animated {
    transform: rotate(180deg);
    background-color: violet;
}
```
Nu het interessante gedeelte: de JavaScript. Ik heb een functie gemaakt, die wordt aangeroepen op het moment dat de gebruiker door de window heen scrolt (zie de eventlistener). Daarvoor heb ik een variabele all_animated_elements aangemaakt waarin ik alle elementen ophaal die ik wil laten animeren. Ook heb ik de hoogte van het scherm alvast opgehaald.
Bij iedere functieaanroep wordt vervolgens voor ieder element apart gekeken of de top positie van het element lager is dan de hoogte van het volledige scherm. De top positie (element_top) is de afstand tussen het element en de bovenkant van de volledige website. De bottom positie (element_bottom) is hetzelfde als de top positie, maar dan de hoogte van het element daarbij opgeteld. Als de waarde van element_top kleiner is dan de hoogte van het scherm en de waarde van element_bottom groter is dan nul, dan is het element per definitie (gedeeltelijk) op het scherm zichtbaar. In dat geval geef ik de class animated mee. Als deze conditie false meegeeft, dan wordt de class weer verwijderd. Bij het meegeven van deze class wordt de CSS transition uitgevoerd. Zie de JavaScript hieronder:
```
function animateElement() {
    for (let idx = 0; idx < total_animated_elements.length; idx++) {
        const element = total_animated_elements[idx];
        const element_top = element.getBoundingClientRect().top;
        const element_bottom = element.getBoundingClientRect().bottom;
        if (element_top < window_height && element_bottom > 0) {
            element.classList.add("animated");
        }
        else {
            element.classList.remove("animated");
        }
    }
}

const total_animated_elements = document.querySelectorAll(".animate_on_scroll");
const window_height = window.innerHeight;
window.addEventListener("scroll", animateElement);
```
Zoals je ziet is er dus helemaal niet zoveel JavaScript voor nodig om al een werkende scrolling animation te maken. Dit is natuurlijk best wel een basic voorbeeld, maar je zou natuurlijk allerlei gave features hieraan kunnen toevoegen door elke shape een totaal andere animatie mee te geven. Nog een vet idee is om sommige elementen steeds iets verder te bewegen wanneer de gebruiker door het element heen blijft scrollen.
Een live demo is hier te vinden: https://codepen.io/dustinschouten/pen/RwQxjew

Bron:
https://alvarotrigo.com/blog/css-animations-scroll/#:~:text=What%20are%20CSS%20Scroll%20Animations,text%2C%20images%2C%20and%20videos.

#### Artikel 2: Websockets met socket.io
Socket.io is een JavaScript library die het mogelijk maakt om realtime informatie uit te wisselen tussen meerdere clients mogelijk maakt doormiddel van een gedeelde server. Het maakt, zoals de naam al suggereert, gebruik van websockets. Websocket is een netwerkprotocol dat communicatie over een TCP (wordt standaard gebruikt om gegevens over het internet of tussen apparaten onderling uit te wisselen) verbinding mogelijk maakt. Het websocket-protocol is niet hetzelfde als het HTTP-protocol. Bij HTTP wordt er vanuit een webbrowser een request wordt gedaan naar een webserver. Die ontvangt het request, stuurt een response naar de client terug en de client ontvangt het response. Hierna wordt de connectie weer afgebroken. Dit is het grote verschil met websockets waarbij de connectie in stand wordt gehouden, wanneer het ene apparaat een bericht verstuurt naar het andere apparaat. Deze connectie wordt pas afgebroken op het moment dat iemand de verbinding verbreekt.
Socket.io is, zoals gezegd, bovenop het WebSocket-protocol gebouwd en heeft een extra voordeel: zodra de connectie onbedoeld toch afgebroken wordt, schakelt het over op HTTP long-polling. Bij HTTP long-polling probeert een server een verbinding met een client zo lang mogelijk in stand te houden, totdat de client weer verbinding maakt of er een time-outdrempel wordt bereikt.
Maar wat kun je allemaal met socket.io en hoe zet je een project met socket.io op? Allereerst maak je met het commando npm init een nieuw project aan waarna je de package socket.io installeert met het commando npm install socket.io. Vervolgens zet je het raamwerk van je applicatie op:
De HTML ziet er zo uit:
```
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
  </head>
  <body>
    <!-- Alle content -->
    <script src="/socket.io/socket.io.js"></script>
    <script src="/script.js"></script>
  </body>
</html>
```
Zoals je ziet zet je de line <script src="/socket.io/socket.io.js"></script> onderaan in je body en boven je JavaScript bestand waar je alle client-side code gaat schrijven.
Nu de JavaScript. Op de client definieer je voor iedere socketverbinding wat er gebeurt als je een bericht verstuurt en als je een bericht van een andere client via de server ontvangt.
Met socket.emit(connectienaam, data); geef je aan naar welke socket-connnectie je wilt versturen en welke data je wilt versturen. Denk hierbij aan een bericht zoals je die ook in een chatprogramma verstuurt. Met socket.on(connectienaam, (data) => { functie }); geef je aan wat er moet gebeuren op de client wanneer je van de server een bericht vanuit een socket-connectie ontvangt.
Als je socket.emit(connectienaam, data); gebruikt, verstuur je de data naar ALLE andere clients die op dat moment met de server verbonden zijn. Met alle clients bedoel ik dus ook naar jezelf. Wanneer je een bericht naar alle clients wilt sturen BEHALVE naar jezelf, gebruik je socket.broadcast.emit(connectienaam, data);.
Wanneer je specifiek naar één of slechts een paar andere mensen een bericht wilt sturen, kun je gebruikmaken van zogenaamde rooms. Met socket.join(room) kan een client zich aansluiten bij een room.
Nu is het tijd om te kijken naar een eenvoudig voorbeeld te kijken waarbij een gebruiker zich aanmeldt in een specifieke room en na zijn aanmelding daar een bericht over krijgt.
Client side JavaScript:
```
let socket = io()

let name = prompt("Voer je naam in: ");
let room = prompt("Voer een room in: ");

socket.emit('connected',name,room);
  
socket.on('receivemessage', (data) => {
    let name = data['name'];
    let room = data['room'];
    console.log(name + ' is aangemeld in room ' + room + '!');
});
```
Server side JavaScript:
```
const express = require('express')
const app = express()
const http = require('http').createServer(app)
const io = require('socket.io')(http)
const port = process.env.PORT || 8000

app.use(express.static(path.resolve('public')))

io.on('connection', (socket) => {
    socket.on('connected', (name,room) => {
        io.to(room).emit('receivemessage',{'name':name,'room':room});
    })
})

http.listen(port, () => {
    console.log('listening on port ', port)
})
```
Op de client voert de gebruiker een naam en een room in waarna hij/zij wordt aangemeld doormiddel van de connectie ‘connected’. Op de server begin je altijd met io.on('connection', (socket) => { ..jouw sockets.. }); De socketverbinding ‘connection’ is eens standaard ingebouwde connection waarbinnen je je server-afhandelingen kan schrijven. De socket-verbinding ‘connected’ die op de client is gedefinieerd, moet ook op de server gedefinieerd worden zodat er op die manier gegevensuitwisseling tussen client en server kan plaatsvinden.  Met de line io.to(room).emit('receivemessage',{'name':name,'room':room}); op de server wordt er naar alle clients in de aangegeven room de ingevoerde naam en het bijbehorende roomnummer gestuurd. Op de client vervolgens met de line socket.on('receivemessage', (data) => { ..jouw code..}) deze data ontvangen. 
In mijn voorbeeld wordt slechts een console.log gedaan maar in feite kun je hier allerlei gave functionaliteiten mee maken, zoals een chatprogramma. Je zou met socket.io zelfs super vette multiplayer games mee maken, door iedere vorm van interactie van een speler direct via een server naar de tegenstander te sturen. 
Bron:
https://socket.io/docs/v4/
https://ably.com/topic/websockets-vs-http#:~:text=Unlike%20HTTP%2C%20where%20you%20have,request%2Fresponse%2Dbased%20methods.

#### Artikel 3: Hoe maak ik mijn websites beter zichtbaar voor zoekmachines?
Iedereen die voor zijn/haar bedrijf een website/webshop heeft, wil dat zoveel mogelijk potentiële klanten deze website bezoeken. Daarom is het natuurlijk belangrijk dat jouw website zo hoog mogelijk in de zoekresultaten van zoekmachines zoals Google terechtkomt. Hierbij gaat het over Search engine optimization (SEO). Maar hoe kun je daar het beste voor zorgen? Op welke (technische) aspecten moet je letten bij het ontwikkelen van jouw website zodat zoekmachines jouw website makkelijker kunnen vinden? Daar ga ik in dit artikel op in.
Maar eerst even iets over webcrawlers:
Een website is pas vindbaar als die bezocht is door een zoekrobot en in de resultaten is opgenomen. Zoekmachines gebruiken zoekrobots (die heten ‘webcrawlers’) om online pagina’s op websites te bezoeken. Deze webcrawlers proberen te begrijpen welke informatie jouw webpagina's biedt voor bezoekers. Hiervoor kijkt zo'n webcrowler naar alle content op de website zoals head- en bodyteksten, afbeeldingen en links. Wanneer de webcrowler deze content heeft geanalyseerd, wordt er een algoritme toegepast om te bepalen voor welke zoekopdrachten de website een goed resultaat is. Ook wordt gekeken hoe goed het resultaat is in vergelijking met andere websites met soortgelijke content.
Er worden aannames gemaakt dat zoekmachines op basis van meer dan 200 factoren (die allemaal een andere weging hebben) de afweging maken hoe goed een website scoort in de zoekresultaten.
Dus hoe kun je jouw website zo SEO-proof mogelijk maken? Daar zijn een aantal manieren voor:
- Schrijf teksten met keywords waar webcrawlers op kunnen zoeken. Keywords zijn de woorden waar mensen in zoekmachines zoals Google naar zoeken. Maar let op: gebruik bij het schrijven keywords niet te vaak en ook niet teveel keywords die als onbelangrijk worden ervaren. Google gaat ervan uit dat deze pagina’s juist weinig meerwaarde voor bezoekers hebben en zal deze pagina’s dus een lagere score toekennen. Denk er ook aan dat concurrenten deze truc ook weten en ook hun content voorzien van de belangrijkste keywords. Probeer daarom, om onderscheidend en relevant te blijven, ook keywords in jouw website op te nemen die iets minder populair maar wel erg nuttig zijn voor jouw bezoekers.
- Zorg voor koppen en subkoppen om teksten te structureren. Gebruik één h1-tag en meerdere h2- en h3-koppen (en lagere tags) om jouw content structuur te geven.
- Zorg dat de link naar jouw website in andere websites wordt opgenomen. Webcrawlers bezoeken zoals gezegd veel websites en gebruiken links om op andere websites terecht te komen. Ook ziet een zoekmachine als Google dit als een vorm van vertrouwen als anderen bereid zijn naar jou te linken.
- Zorg voor goede paginatitels. Dit zijn de titels die bezoekers als eerste in de zoekresultaten zien en vaak maken ze op basis van de titels al hun afweging. Gebruik in de titels minimaal één en maximaal twee trefwoorden. Probeer ook de titels niet te lang te maken.
- Zorg voor alt-teksten bij afbeeldingen.
- Zorg ervoor dat jouw website responsive is. 
- Zorg voor een goede zogenaamde meta-description. Hier wordt gek genoeg niet door webcrawlers naar gekeken, maar dit is wel een belangrijk onderdeel omdat potentiele bezoekers deze informatie na de titel als eerste zien.
- Zorg dat al jouw pagina’s minimaal 250 á 300 woorden bevatten.
- Hoe langer gebruikers op jouw website blijven, hoe belangrijker Google jouw website gaat vinden en dus hoe hoger jij in de zoekresultaten gaat verschijnen. Om bezoekers langer op jouw website te houden moet jij hun in ieder geval voorzien van goed inhoudelijke content, maar ook het design is belangrijk. Een slecht of goedkoop ogende website zorgt voor minder vertrouwen bij jouw gebruikers. Probeer dus professioneel over te komen maar kijk ook of je met jouw designskills jouw bezoekers kunt verrassen.
De tips hierboven waren met name gericht op de content. Maar SEO-crawlers kunnen jouw website ook hoger laten scoren door websites die technisch geoptimaliseerd zijn. Pas hiervoor de volgende optimalisaties toe:
- Voeg een XML-sitemap toe. Dit is een bestand waarin alle url’s van jouw website onder elkaar staan.
- Zorg voor een SSL-certificaat. Wanneer jouw website om persoonsgegevens vraagt is het sowieso verplicht om een SSL-certificaat te hebben sinds de komst van de Algemene Verordening Gegevensbescherming. Met een SSL-certificaat wordt al het dataverkeer op jouw website versleuteld voor cybercriminelen waardoor jij als websitebeheerder laat zien dat je waarde hecht aan de online veiligheid van jouw bezoeker. Daarom is zo’n certificaat ook goed voor je SEO-ranking.
- Zorg ervoor dat jouw website qua laadtijd geen irritatie oplevert bij jouw bezoekers. Een hogere laadsnelheid zorgt voor een hogere SEO-ranking. Om jouw website sneller te laten laden kun je denken aan caching, het gebruik van niet te grote afbeeldingen en het minifyen van jouw HTML, CSS en JavaScript.
- Zorg voor een robots.txt bestand in de rootmap van je website. Dit is het eerste bestand wat door webcrawlers wordt doorzocht. Het robots.txt bestand is een tekstbestand waarin instructies voor zoekmachines staan over hoe ze jouw website moeten ‘crawlen’. Hierin staat welke webpagina’s wel en niet moeten worden doorzocht. Pagina’s die niet doorzocht hoeven worden doordat ze geen positieve invloed op de SEO-score hebben zijn bijvoorbeeld inlog- en contactpagina’s.
Zo zie je dat er een heleboel manieren zijn om jouw website of webshop hoger in de zoekresultaten van zoekmachines te laten verschijnen. Doordat Google de exacte lijst met criteria expres verborgen houdt, kan niet altijd worden vastgesteld of sommige methodes daadwerkelijk een hogere SEO-score zorgen. Maar in ieder geval zie je dat er een flinke ruimte voor verbetering is wanneer je meer bezoekers/klanten (zo lang mogelijk) op jouw website wilt krijgen.
Bronnen:
https://developers.google.com/search/docs/beginner/seo-starter-guide
https://www.jimdo.com/nl/blog/website-advies/wat-is-seo/#:~:text=Zoekmachine%20optimalisatie%20(SEO)%20is%20je,over%20schrijft%20op%20je%20website.
https://webnomad.nl/seo-tips-om-website-optimaliseren-google-handige-checklists/
https://smartranking.nl/zoekmachine-optimalisatie/
https://www.sidn.nl/4-redenen-om-een-ssl-certificaat-voor-je-website-te-gebruiken
https://www.tekstmeester.nl/xml-sitemap/
